{"version":3,"file":"index.cjs","sources":["../src/constants.ts","../src/utils/array.ts","../src/utils/object.ts","../src/utils/mapping.ts","../src/utils/key.ts","../src/utils/merge.ts","../src/utils/relation.ts","../src/utils/url.ts","../src/parameter/fields/build.ts","../src/parameter/fields/constants.ts","../src/errors/code.ts","../src/errors/base.ts","../src/errors/build.ts","../src/errors/parse.ts","../src/parameter/fields/errors/build.ts","../src/parameter/fields/errors/parse.ts","../src/parameter/utils/parse/allowed-option.ts","../src/parameter/fields/utils/domain.ts","../src/parameter/fields/utils/input.ts","../src/parameter/fields/utils/name.ts","../src/parameter/fields/parse.ts","../src/parameter/filters/constants.ts","../src/parameter/filters/build.ts","../src/parameter/filters/errors/build.ts","../src/parameter/filters/errors/parse.ts","../src/parameter/filters/utils/value.ts","../src/parameter/filters/utils/operator.ts","../src/parameter/filters/parse.ts","../src/parameter/pagination/build.ts","../src/parameter/pagination/errors/build.ts","../src/parameter/pagination/errors/parse.ts","../src/parameter/pagination/parse.ts","../src/parameter/relations/build.ts","../src/parameter/relations/errors/build.ts","../src/parameter/relations/errors/parse.ts","../src/parameter/relations/utils/parents.ts","../src/parameter/relations/utils/path.ts","../src/parameter/relations/parse.ts","../src/parameter/sort/type.ts","../src/parameter/sort/build.ts","../src/parameter/sort/errors/build.ts","../src/parameter/sort/errors/parse.ts","../src/parameter/sort/utils.ts","../src/parameter/sort/parse.ts","../src/build/module.ts","../src/parse/parameter/module.ts","../src/parse/parameter/utils.ts","../src/parse/module.ts"],"sourcesContent":["/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\n// -----------------------------------------------------------\n\nexport enum Parameter {\n    FILTERS = 'filters',\n    FIELDS = 'fields',\n    PAGINATION = 'pagination',\n    RELATIONS = 'relations',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport enum URLParameter {\n    FILTERS = 'filter',\n    FIELDS = 'fields',\n    PAGINATION = 'page',\n    RELATIONS = 'include',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport const DEFAULT_ID = '__DEFAULT__';\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../constants';\n\nexport function buildKeyPath(key: string, prefix?: string) {\n    if (typeof prefix === 'string') {\n        return `${prefix}.${key}`;\n    }\n\n    return key;\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: string[],\n        prefix?: string\n    ) => boolean | undefined\n};\n\nexport function flattenToKeyPathArray(\n    input: unknown,\n    options?: Options,\n    prefix?: string,\n): string[] {\n    options = options || {};\n\n    const output: string[] = [];\n\n    if (options.transformer) {\n        const result = options.transformer(input, output, prefix);\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (options.transformer) {\n                const result = options.transformer(input[i], output, prefix);\n                if (typeof result !== 'undefined' && !!result) {\n                    return output;\n                }\n            }\n\n            if (Array.isArray(input[i])) {\n                for (let j = 0; j < input[i].length; j++) {\n                    const key = buildKeyPath(input[i][j], prefix);\n                    output.push(key);\n                }\n\n                continue;\n            }\n\n            if (typeof input[i] === 'string') {\n                output.push(buildKeyPath(input[i], prefix));\n\n                continue;\n            }\n\n            if (typeof input[i] === 'object') {\n                const keys = Object.keys(input[i]);\n                for (let j = 0; j < keys.length; j++) {\n                    const value = buildKeyPath(keys[j] as string, prefix);\n                    const data = flattenToKeyPathArray(input[i][keys[j]], options, value);\n                    if (data.length === 0) {\n                        output.push(value);\n                    } else {\n                        output.push(...data);\n                    }\n                }\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'object' &&\n        input !== null\n    ) {\n        const keys = Object.keys(input);\n        for (let i = 0; i < keys.length; i++) {\n            const value = buildKeyPath(keys[i], prefix);\n            const data = flattenToKeyPathArray((input as Record<string, any>)[keys[i]], options, value);\n            if (data.length === 0) {\n                output.push(value);\n            } else {\n                output.push(...data);\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'string'\n    ) {\n        const value = buildKeyPath(input, prefix);\n        output.push(value);\n\n        return output;\n    }\n\n    return output;\n}\n\nexport function groupArrayByKeyPath(input: string[]): Record<string, string[]> {\n    const pathItems: Record<string, string[]> = {};\n\n    for (let i = 0; i < input.length; i++) {\n        const parts = input[i].split('.');\n\n        let key: string;\n        let name: string;\n        if (parts.length === 1) {\n            key = DEFAULT_ID;\n            name = input[i];\n        } else {\n            name = parts.pop() as string;\n            key = parts.join('.');\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(pathItems, key)) {\n            pathItems[key] = [];\n        }\n\n        pathItems[key].push(name);\n    }\n\n    return pathItems;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isObject(item: unknown) : item is Record<string, any> {\n    return (\n        !!item &&\n        typeof item === 'object' &&\n        !Array.isArray(item)\n    );\n}\nexport function hasOwnProperty<\n    X extends Record<string, any>,\n    Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: Record<string, any>,\n        key: string\n    ) => boolean | undefined\n};\n\nexport function flattenNestedObject(\n    data: Record<string, any>,\n    options?: Options,\n    prefixParts?: string[],\n): Record<string, any> {\n    options = options || {};\n    prefixParts = prefixParts || [];\n\n    let output: Record<string, string> = {};\n\n    if (options.transformer) {\n        const result = options.transformer(data, output, prefixParts.join('.'));\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (options.transformer) {\n            const result = options.transformer(data[key], output, [...prefixParts, key].join('.'));\n            if (typeof result !== 'undefined' && !!result) {\n                continue;\n            }\n        }\n\n        if (\n            typeof data[key] === 'object' &&\n            data[key]\n        ) {\n            output = { ...output, ...flattenNestedObject(data[key], options, [...prefixParts, key]) };\n\n            continue;\n        }\n\n        const destinationKey = [...prefixParts, key].join('.');\n\n        if (\n            typeof data[key] === 'boolean' ||\n            typeof data[key] === 'string' ||\n            typeof data[key] === 'number' ||\n            typeof data[key] === 'undefined' ||\n            data[key] === null ||\n            Array.isArray(data[key])\n        ) {\n            output[destinationKey] = data[key];\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty } from './object';\n\nexport function applyMapping(\n    name: string,\n    map?: Record<string, string>,\n    onlyKey?: boolean,\n) {\n    if (typeof map === 'undefined') {\n        return name;\n    }\n\n    const keys = Object.keys(map);\n    if (keys.length === 0) {\n        return name;\n    }\n\n    let parts = name.split('.');\n\n    const output = [];\n    let run = true;\n    while (run) {\n        const value = parts.shift();\n        if (typeof value === 'undefined') {\n            run = false;\n            break;\n        }\n\n        if (hasOwnProperty(map, value)) {\n            output.push(map[value]);\n        } else {\n            let found = false;\n\n            const rest : string[] = [];\n            const copy = [...parts];\n            while (copy.length > 0) {\n                const key = [value, ...copy].join('.');\n                if (hasOwnProperty(map, key)) {\n                    output.push(map[key]);\n                    found = true;\n                    break;\n                } else {\n                    const last = copy.pop();\n                    if (last) {\n                        rest.unshift(last);\n                    }\n                }\n            }\n\n            if (found) {\n                parts = rest;\n            } else {\n                output.push(value);\n            }\n        }\n    }\n\n    if (onlyKey) {\n        return output.pop() || name;\n    }\n\n    if (output.length === 0) {\n        return name;\n    }\n\n    return output.join('.');\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { KeyDetails } from './type';\n\nexport function parseKey(\n    field: string,\n) : KeyDetails {\n    const parts : string[] = field.split('.');\n\n    const name = parts.pop() as string;\n\n    return {\n        name,\n        path: parts.length > 0 ? parts.join('.') : undefined,\n    };\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { createMerger } from 'smob';\n\nexport const merge = createMerger({\n    clone: true,\n    inPlace: false,\n    array: true,\n    arrayDistinct: true,\n});\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport type { RelationsParseOutput } from '../parameter';\nimport type { KeyDetails } from './type';\n\nexport function isPathAllowedByRelations(\n    path?: string,\n    includes?: RelationsParseOutput,\n) : boolean {\n    if (typeof path === 'undefined' || typeof includes === 'undefined') {\n        return true;\n    }\n\n    return includes.some(\n        (include) => include.key === path,\n    );\n}\n\nexport function buildKeyWithPath(input: KeyDetails) : string;\nexport function buildKeyWithPath(key: string, path: string): string;\nexport function buildKeyWithPath(\n    name: string | KeyDetails,\n    path?: string,\n) : string {\n    let details : KeyDetails;\n    if (isObject(name)) {\n        details = name;\n    } else {\n        details = {\n            name,\n            path,\n        };\n    }\n\n    return details.path || path ?\n        `${details.path || path}.${details.name}` :\n        details.name;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\n\nexport function buildURLQueryString(data?: any, withQuestionMark = true) {\n    if (typeof data === 'undefined' || data === null) return '';\n\n    // If the data is already a string, return it as-is\n    if (typeof data === 'string') return data;\n\n    // Create a query array to hold the key/value pairs\n    const query : string[] = [];\n\n    // Loop through the data object\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        let value = data[keys[i]];\n\n        if (isObject(value)) {\n            const valueKeys = Object.keys(value);\n            for (let j = 0; j < valueKeys.length; j++) {\n                let v = value[valueKeys[j]];\n\n                if (Array.isArray(v)) {\n                    v = v.join(',');\n                }\n\n                query.push(`${encodeURIComponent(`${keys[i]}[${valueKeys[j]}]`)}=${encodeURIComponent(v)}`);\n            }\n\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        // Encode each key and value, concatenate them into a string, and push them to the array\n        query.push(`${encodeURIComponent(keys[i])}=${encodeURIComponent(value)}`);\n    }\n\n    // Join each item in the array with a `&` and return the resulting string\n    return (withQuestionMark ? '?' : '') + query.join('&');\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../../type';\nimport type { FieldsBuildInput } from './type';\nimport { flattenToKeyPathArray, groupArrayByKeyPath, merge } from '../../utils';\n\nexport function buildQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input?: FieldsBuildInput<T>,\n) : Record<string, string[]> | string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    const data = groupArrayByKeyPath(flattenToKeyPathArray(input));\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n\nexport function mergeQueryFields(\n    target: Record<string, string[]> | string[],\n    source: Record<string, string[]> | string[],\n): Record<string, string[]> | string[] {\n    if (Array.isArray(target)) {\n        target = groupArrayByKeyPath(target);\n    }\n\n    if (Array.isArray(source)) {\n        source = groupArrayByKeyPath(source);\n    }\n\n    const data = merge(target, source);\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FieldOperator {\n    INCLUDE = '+',\n    EXCLUDE = '-',\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum ErrorCode {\n    NONE = 'none',\n\n    INPUT_INVALID = 'inputInvalid',\n\n    KEY_INVALID = 'keyInvalid',\n\n    KEY_PATH_INVALID = 'keyPathInvalid',\n\n    KEY_NOT_ALLOWED = 'keyNotAllowed',\n\n    KEY_VALUE_INVALID = 'keyValueInvalid',\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BaseError as Base } from 'ebec';\nimport { ErrorCode } from './code';\n\nexport class BaseError extends Base {\n    get code() : `${ErrorCode}` {\n        return this.getOption('code') as `${ErrorCode}` || ErrorCode.NONE;\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { Options } from 'ebec';\nimport { isObject } from '../utils';\nimport { BaseError } from './base';\n\nexport class BuildError extends BaseError {\n    constructor(message?: string | Options) {\n        if (isObject(message)) {\n            message.message = 'A building error has occurred.';\n        }\n\n        super(message || 'A building error has occurred.');\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { Options } from 'ebec';\nimport { isObject } from '../utils';\nimport { BaseError } from './base';\nimport { ErrorCode } from './code';\n\nexport class ParseError extends BaseError {\n    constructor(message?: string | Options) {\n        if (isObject(message)) {\n            message.message = message.message || 'A parsing error has occurred.';\n        }\n\n        super(message || 'A parsing error has occurred.');\n    }\n\n    static inputInvalid() {\n        return new this({\n            message: 'The shape of the input is not valid.',\n            code: ErrorCode.INPUT_INVALID,\n        });\n    }\n\n    static keyNotAllowed(name: string) {\n        return new this({\n            message: `The key ${name} is not covered by allowed/default options.`,\n            code: ErrorCode.KEY_NOT_ALLOWED,\n        });\n    }\n\n    static keyInvalid(key: string) {\n        return new this({\n            message: `The key ${key} is invalid.`,\n            code: ErrorCode.KEY_INVALID,\n        });\n    }\n\n    static keyPathInvalid(key: string) {\n        return new this({\n            message: `The key path ${key} is invalid.`,\n            code: ErrorCode.KEY_PATH_INVALID,\n        });\n    }\n\n    static keyValueInvalid(key: string) {\n        return new this({\n            message: `The value of the key ${key} is invalid.`,\n            code: ErrorCode.KEY_VALUE_INVALID,\n        });\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BuildError } from '../../../errors';\n\nexport class FieldsBuildError extends BuildError {\n\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ParseError } from '../../../errors';\n\nexport class FieldsParseError extends ParseError {\n\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { NestedKeys, NestedResourceKeys, ObjectLiteral } from '../../../type';\nimport { flattenToKeyPathArray } from '../../../utils';\nimport type { ParseAllowedOption } from '../../type';\n\nexport function flattenParseAllowedOption<T extends ObjectLiteral>(\n    input?: ParseAllowedOption<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function isPathCoveredByParseAllowedOption<T extends ObjectLiteral>(\n    input: ParseAllowedOption<T> |\n    NestedKeys<T>[] |\n    NestedResourceKeys<T>[],\n    path: string | string[],\n) : boolean {\n    const paths = Array.isArray(path) ? path : [path];\n\n    const items = flattenToKeyPathArray(input);\n    for (let i = 0; i < items.length; i++) {\n        if (paths.indexOf(items[i]) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../../../constants';\n\nexport function buildFieldDomainRecords(\n    data?: Record<string, string[]> | string[],\n): Record<string, string[]> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    let domainFields: Record<string, string[]> = {};\n\n    if (Array.isArray(data)) {\n        domainFields[DEFAULT_ID] = data;\n    } else {\n        domainFields = data;\n    }\n\n    return domainFields;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function parseFieldsInput(input: unknown): string[] {\n    let output: string[] = [];\n\n    if (typeof input === 'string') {\n        output = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                output.push(input[i]);\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidFieldName(input: string) : boolean {\n    return /^[a-zA-Z_][a-zA-Z0-9_]*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { distinctArray, isObject } from 'smob';\nimport { DEFAULT_ID } from '../../constants';\nimport type { ObjectLiteral } from '../../type';\nimport {\n    applyMapping, groupArrayByKeyPath, hasOwnProperty, isPathAllowedByRelations, merge,\n} from '../../utils';\nimport { flattenParseAllowedOption } from '../utils';\nimport { FieldOperator } from './constants';\nimport { FieldsParseError } from './errors';\nimport type { FieldsInputTransformed, FieldsParseOptions, FieldsParseOutput } from './type';\nimport { isValidFieldName, parseFieldsInput } from './utils';\n\n// --------------------------------------------------\n\nfunction buildReverseRecord(\n    record: Record<string, string>,\n) : Record<string, string> {\n    const keys = Object.keys(record);\n    const output : Record<string, string> = {};\n\n    for (let i = 0; i < keys.length; i++) {\n        output[record[keys[i]]] = keys[i];\n    }\n\n    return output;\n}\n\nexport function parseQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options?: FieldsParseOptions<T>,\n) : FieldsParseOutput {\n    options = options || {};\n\n    const defaultDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.default),\n    );\n\n    const allowedDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.allowed),\n    );\n\n    const domainFields = merge(\n        defaultDomainFields,\n        allowedDomainFields,\n    );\n\n    let keys : string[] = Object.keys(domainFields);\n\n    // If it is an empty array nothing is allowed\n    if (\n        (typeof options.default !== 'undefined' || typeof options.allowed !== 'undefined') &&\n        keys.length === 0\n    ) {\n        return [];\n    }\n\n    let data : Record<string, any> = {\n        [DEFAULT_ID]: [],\n    };\n\n    if (isObject(input)) {\n        data = input;\n    } else if (typeof input === 'string' || Array.isArray(input)) {\n        data = { [DEFAULT_ID]: input };\n    } else if (options.throwOnFailure) {\n        throw FieldsParseError.inputInvalid();\n    }\n\n    options.mapping = options.mapping || {};\n    const reverseMapping = buildReverseRecord(options.mapping);\n\n    if (\n        keys.length > 0 &&\n        hasOwnProperty(data, DEFAULT_ID)\n    ) {\n        data = {\n            [keys[0]]: data[DEFAULT_ID],\n        };\n    } else {\n        keys = distinctArray([...keys, ...Object.keys(data)]);\n    }\n\n    const output : FieldsParseOutput = [];\n\n    for (let i = 0; i < keys.length; i++) {\n        const path = keys[i];\n\n        if (\n            path !== DEFAULT_ID &&\n            !isPathAllowedByRelations(path, options.relations)\n        ) {\n            if (options.throwOnFailure) {\n                throw FieldsParseError.keyPathInvalid(path);\n            }\n\n            continue;\n        }\n\n        let fields : string[] = [];\n\n        if (hasOwnProperty(data, path)) {\n            fields = parseFieldsInput(data[path]);\n        } else if (\n            hasOwnProperty(reverseMapping, path) &&\n            hasOwnProperty(data, reverseMapping[path])\n        ) {\n            fields = parseFieldsInput(data[reverseMapping[path]]);\n        }\n\n        const transformed : FieldsInputTransformed = {\n            default: [],\n            included: [],\n            excluded: [],\n        };\n\n        if (fields.length > 0) {\n            for (let j = 0; j < fields.length; j++) {\n                let operator: FieldOperator | undefined;\n\n                const character = fields[j].substring(0, 1);\n\n                if (character === FieldOperator.INCLUDE) {\n                    operator = FieldOperator.INCLUDE;\n                } else if (character === FieldOperator.EXCLUDE) {\n                    operator = FieldOperator.EXCLUDE;\n                }\n\n                if (operator) {\n                    fields[j] = fields[j].substring(1);\n                }\n\n                fields[j] = applyMapping(fields[j], options.mapping, true);\n\n                let isValid : boolean;\n                if (hasOwnProperty(domainFields, path)) {\n                    isValid = domainFields[path].indexOf(fields[j]) !== -1;\n                } else {\n                    isValid = isValidFieldName(fields[j]);\n                }\n\n                if (!isValid) {\n                    if (options.throwOnFailure) {\n                        throw FieldsParseError.keyNotAllowed(fields[j]);\n                    }\n\n                    continue;\n                }\n\n                if (operator === FieldOperator.INCLUDE) {\n                    transformed.included.push(fields[j]);\n                } else if (operator === FieldOperator.EXCLUDE) {\n                    transformed.excluded.push(fields[j]);\n                } else {\n                    transformed.default.push(fields[j]);\n                }\n            }\n        }\n\n        if (\n            transformed.default.length === 0 &&\n            hasOwnProperty(defaultDomainFields, path)\n        ) {\n            transformed.default = defaultDomainFields[path];\n        }\n\n        if (\n            transformed.included.length === 0 &&\n            transformed.default.length === 0 &&\n            hasOwnProperty(allowedDomainFields, path)\n        ) {\n            transformed.default = allowedDomainFields[path];\n        }\n\n        transformed.default = Array.from(new Set([\n            ...transformed.default,\n            ...transformed.included,\n        ]));\n\n        for (let j = 0; j < transformed.excluded.length; j++) {\n            const index = transformed.default.indexOf(transformed.excluded[j]);\n            if (index !== -1) {\n                transformed.default.splice(index, 1);\n            }\n        }\n\n        if (transformed.default.length > 0) {\n            for (let j = 0; j < transformed.default.length; j++) {\n                let destPath : string | undefined;\n                if (path !== DEFAULT_ID) {\n                    destPath = path;\n                } else if (options.defaultPath) {\n                    destPath = options.defaultPath;\n                }\n\n                output.push({\n                    key: transformed.default[j],\n                    ...(destPath ? { path: destPath } : {}),\n                });\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FilterComparisonOperator {\n    EQUAL = '$eq',\n    NOT_EQUAL = '$ne',\n    LIKE = '$l',\n    NOT_LIKE = '$nl',\n    LESS_THAN_EQUAL = '$lte',\n    LESS_THAN = '$lt',\n    GREATER_THAN_EQUAL = '$gte',\n    GREATER_THAN = '$gt',\n    IN = '$in',\n    NOT_IN = '$nin',\n}\n\nexport enum FilterInputOperatorValue {\n    NEGATION = '!',\n    LIKE = '~',\n    LESS_THAN_EQUAL = '<=',\n    LESS_THAN = '<',\n    MORE_THAN_EQUAL = '>=',\n    MORE_THAN = '>',\n    IN = ',',\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { flattenNestedObject, merge } from '../../utils';\nimport type { ObjectLiteral } from '../../type';\nimport type { FiltersBuildInput } from './type';\n\nexport function buildQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data?: FiltersBuildInput<T>,\n) : Record<string, any> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    return flattenNestedObject(data, {\n        transformer: (input, output, key) => {\n            if (typeof input === 'undefined') {\n                output[key] = null;\n\n                return true;\n            }\n\n            if (Array.isArray(input)) {\n                // preserve null values\n                const data : string[] = [];\n                for (let i = 0; i < input.length; i++) {\n                    if (input[i] === null) {\n                        input[i] = 'null';\n                    }\n\n                    if (typeof input[i] === 'number') {\n                        input[i] = `${input[i]}`;\n                    }\n\n                    if (typeof input[i] === 'string') {\n                        data.push(input[i]);\n                    }\n                }\n\n                output[key] = data.join(',');\n\n                return true;\n            }\n\n            return undefined;\n        },\n    });\n}\n\nexport function mergeQueryFilters(\n    target?: Record<string, any>,\n    source?: Record<string, any>,\n) : Record<string, any> {\n    return merge(target || {}, source || {});\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BuildError } from '../../../errors';\n\nexport class FiltersBuildError extends BuildError {\n\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ParseError } from '../../../errors';\n\nexport class FiltersParseError extends ParseError {\n\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { FilterValueSimple } from '../type';\n\nexport function transformFilterValue(input: FilterValueSimple) : FilterValueSimple {\n    if (typeof input === 'string') {\n        input = input.trim();\n        const lower = input.toLowerCase();\n\n        if (lower === 'true') {\n            return true;\n        }\n\n        if (lower === 'false') {\n            return false;\n        }\n\n        if (lower === 'null') {\n            return null;\n        }\n\n        if (input.length === 0) {\n            return input;\n        }\n\n        const num = Number(input);\n        if (!Number.isNaN(num)) {\n            return num;\n        }\n\n        const parts = input.split(',');\n        if (parts.length > 1) {\n            return transformFilterValue(parts);\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            input[i] = transformFilterValue(input[i]) as string | number;\n        }\n\n        return (input as unknown[])\n            .filter((n) => n === 0 || n === null || !!n) as FilterValueSimple;\n    }\n\n    if (typeof input === 'undefined' || input === null) {\n        return null;\n    }\n\n    return input;\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FilterComparisonOperator, FilterInputOperatorValue } from '../constants';\nimport type { FilterValueSimple } from '../type';\n\nfunction matchOperator(key: string, value: FilterValueSimple, position: 'start' | 'end' | 'global') : FilterValueSimple | undefined {\n    if (typeof value === 'string') {\n        switch (position) {\n            case 'start': {\n                if (value.substring(0, key.length) === key) {\n                    return value.substring(key.length);\n                }\n                break;\n            }\n            case 'end': {\n                if (value.substring(0 - key.length) === key) {\n                    return value.substring(0, value.length - key.length - 1);\n                }\n                break;\n            }\n        }\n\n        return undefined;\n    }\n\n    if (Array.isArray(value)) {\n        let match = false;\n        for (let i = 0; i < value.length; i++) {\n            const output = matchOperator(key, value[i], position);\n            if (typeof output !== 'undefined') {\n                match = true;\n                value[i] = output as string | number;\n            }\n        }\n\n        if (match) {\n            return value;\n        }\n    }\n\n    return undefined;\n}\n\nexport function parseFilterValue(input: FilterValueSimple) : {\n    operator: `${FilterComparisonOperator}`,\n    value: FilterValueSimple\n} {\n    if (\n        typeof input === 'string' &&\n        input.includes(FilterInputOperatorValue.IN)\n    ) {\n        input = input.split(FilterInputOperatorValue.IN);\n    }\n\n    let negation = false;\n\n    let value = matchOperator(FilterInputOperatorValue.NEGATION, input, 'start');\n    if (typeof value !== 'undefined') {\n        negation = true;\n        input = value;\n    }\n\n    if (Array.isArray(input)) {\n        return {\n            value: input,\n            operator: negation ?\n                FilterComparisonOperator.NOT_IN :\n                FilterComparisonOperator.IN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LIKE, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: negation ?\n                FilterComparisonOperator.NOT_LIKE :\n                FilterComparisonOperator.LIKE,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN,\n        };\n    }\n\n    return {\n        value: input,\n        operator: negation ?\n            FilterComparisonOperator.NOT_EQUAL :\n            FilterComparisonOperator.EQUAL,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { NestedKeys, ObjectLiteral } from '../../type';\nimport type { KeyDetails } from '../../utils';\nimport {\n    applyMapping,\n    buildKeyWithPath,\n    flattenNestedObject,\n    hasOwnProperty,\n    isObject,\n    isPathAllowedByRelations,\n    parseKey,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport type { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\nimport { FilterComparisonOperator } from './constants';\nimport { FiltersParseError } from './errors';\nimport type { FiltersParseOptions, FiltersParseOutput, FiltersParseOutputElement } from './type';\nimport { parseFilterValue, transformFilterValue } from './utils';\n\n// --------------------------------------------------\n// ^([0-9]+(?:\\.[0-9]+)*){0,1}([a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]+)*){0,1}$\nfunction transformFiltersParseOutputElement(element: FiltersParseOutputElement) : FiltersParseOutputElement {\n    if (\n        hasOwnProperty(element, 'path') &&\n        (typeof element.path === 'undefined' || element.path === null)\n    ) {\n        delete element.path;\n    }\n\n    if (element.operator) {\n        return element;\n    }\n\n    if (typeof element.value === 'string') {\n        element = {\n            ...element,\n            ...parseFilterValue(element.value),\n        };\n    } else {\n        element.operator = FilterComparisonOperator.EQUAL;\n    }\n\n    element.value = transformFilterValue(element.value);\n\n    return element;\n}\n\nfunction buildDefaultFiltersParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: FiltersParseOptions<T>,\n    input: Record<string, FiltersParseOutputElement> = {},\n) : FiltersParseOutput {\n    const inputKeys = Object.keys(input || {});\n\n    if (\n        !options.defaultByElement &&\n        inputKeys.length > 0\n    ) {\n        return Object.values(input);\n    }\n\n    if (options.default) {\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        const output : FiltersParseOutput = [];\n\n        for (let i = 0; i < keys.length; i++) {\n            const keyDetails = parseKey(keys[i]);\n\n            if (\n                options.defaultByElement &&\n                inputKeys.length > 0\n            ) {\n                const keyWithPath = buildKeyWithPath(keyDetails);\n                if (hasOwnProperty(input, keyWithPath)) {\n                    continue;\n                }\n            }\n\n            if (options.defaultByElement || inputKeys.length === 0) {\n                let path : string | undefined;\n                if (keyDetails.path) {\n                    path = keyDetails.path;\n                } else if (options.defaultPath) {\n                    path = options.defaultPath;\n                }\n\n                output.push(transformFiltersParseOutputElement({\n                    ...(path ? { path } : {}),\n                    key: keyDetails.name,\n                    value: flatten[keys[i]],\n                }));\n            }\n        }\n\n        return input ? [...Object.values(input), ...output] : output;\n    }\n\n    return input ? Object.values(input) : [];\n}\n\nexport function parseQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: FiltersParseOptions<T>,\n) : FiltersParseOutput {\n    options = options || {};\n    options.mapping = options.mapping || {};\n    options.relations = options.relations || [];\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        options.allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (options.allowed.length === 0) {\n            return buildDefaultFiltersParseOutput(options);\n        }\n    }\n\n    /* istanbul ignore next */\n    if (!isObject(data)) {\n        if (options.throwOnFailure) {\n            throw FiltersParseError.inputInvalid();\n        }\n\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    const { length } = Object.keys(data);\n    if (length === 0) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    if (\n        (typeof options.allowed === 'undefined' || options.allowed.length === 0) &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    const items : Record<string, FiltersParseOutputElement> = {};\n\n    // transform to appreciate data format & validate input\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        const value : unknown = data[keys[i]];\n\n        if (\n            typeof value !== 'string' &&\n            typeof value !== 'number' &&\n            typeof value !== 'boolean' &&\n            typeof value !== 'undefined' &&\n            value !== null &&\n            !Array.isArray(value)\n        ) {\n            if (options.throwOnFailure) {\n                throw FiltersParseError.keyValueInvalid(keys[i]);\n            }\n            continue;\n        }\n\n        keys[i] = applyMapping(keys[i], options.mapping);\n\n        const fieldDetails : KeyDetails = parseKey(keys[i]);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            if (options.throwOnFailure) {\n                throw FiltersParseError.keyInvalid(fieldDetails.name);\n            }\n            continue;\n        }\n\n        if (\n            typeof fieldDetails.path !== 'undefined' &&\n            !isPathAllowedByRelations(fieldDetails.path, options.relations)\n        ) {\n            if (options.throwOnFailure) {\n                throw FiltersParseError.keyPathInvalid(fieldDetails.path);\n            }\n            continue;\n        }\n\n        const fullKey : string = buildKeyWithPath(fieldDetails);\n\n        if (\n            options.allowed &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [keys[i], fullKey])\n        ) {\n            if (options.throwOnFailure) {\n                throw FiltersParseError.keyInvalid(fieldDetails.name);\n            }\n\n            continue;\n        }\n\n        const filter = transformFiltersParseOutputElement({\n            key: fieldDetails.name,\n            value: value as string | boolean | number,\n        });\n\n        if (options.validate) {\n            if (Array.isArray(filter.value)) {\n                const output : (string | number)[] = [];\n                for (let j = 0; j < filter.value.length; j++) {\n                    if (options.validate(filter.key as NestedKeys<T>, filter.value[j])) {\n                        output.push(filter.value[j]);\n                    } else if (options.throwOnFailure) {\n                        throw FiltersParseError.keyValueInvalid(fieldDetails.name);\n                    }\n                }\n\n                filter.value = output as string[] | number[];\n                if (filter.value.length === 0) {\n                    continue;\n                }\n            } else if (!options.validate(filter.key as NestedKeys<T>, filter.value)) {\n                if (options.throwOnFailure) {\n                    throw FiltersParseError.keyValueInvalid(fieldDetails.name);\n                }\n\n                continue;\n            }\n        }\n\n        if (\n            typeof filter.value === 'string' &&\n            filter.value.length === 0\n        ) {\n            if (options.throwOnFailure) {\n                throw FiltersParseError.keyValueInvalid(fieldDetails.name);\n            }\n\n            continue;\n        }\n\n        if (\n            Array.isArray(filter.value) &&\n            filter.value.length === 0\n        ) {\n            if (options.throwOnFailure) {\n                throw FiltersParseError.keyValueInvalid(fieldDetails.name);\n            }\n\n            continue;\n        }\n\n        if (fieldDetails.path || options.defaultPath) {\n            filter.path = fieldDetails.path || options.defaultPath;\n        }\n\n        items[fullKey] = filter;\n    }\n\n    return buildDefaultFiltersParseOutput(options, items);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { merge } from '../../utils';\nimport type { PaginationBuildInput } from './type';\n\nexport function mergeQueryPagination(\n    target?: PaginationBuildInput,\n    source?: PaginationBuildInput,\n) : PaginationBuildInput {\n    return merge(target || {}, source || {});\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BuildError } from '../../../errors';\n\nexport class PaginationBuildError extends BuildError {\n\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ParseError } from '../../../errors';\n\nexport class PaginationParseError extends ParseError {\n    static limitExceeded(limit: number) {\n        return new this({\n            message: `The pagination limit must not exceed the value of ${limit}.`,\n        });\n    }\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport { PaginationParseError } from './errors';\nimport type { PaginationParseOptions, PaginationParseOutput } from './type';\n\n// --------------------------------------------------\n\nfunction finalizePagination(\n    data: PaginationParseOutput,\n    options: PaginationParseOptions,\n) : PaginationParseOutput {\n    if (typeof options.maxLimit !== 'undefined') {\n        if (\n            typeof data.limit === 'undefined' ||\n            data.limit > options.maxLimit\n        ) {\n            if (options.throwOnFailure) {\n                throw PaginationParseError.limitExceeded(options.maxLimit);\n            }\n\n            data.limit = options.maxLimit;\n        }\n    }\n\n    if (\n        typeof data.limit !== 'undefined' &&\n        typeof data.offset === 'undefined'\n    ) {\n        data.offset = 0;\n    }\n\n    return data;\n}\n\n/**\n * Transform pagination data to an appreciate data format.\n *\n * @param data\n * @param options\n */\nexport function parseQueryPagination(\n    data: unknown,\n    options?: PaginationParseOptions,\n) : PaginationParseOutput {\n    options = options || {};\n\n    const pagination : PaginationParseOutput = {};\n\n    if (!isObject(data)) {\n        if (options.throwOnFailure) {\n            throw PaginationParseError.inputInvalid();\n        }\n\n        return finalizePagination(pagination, options);\n    }\n\n    let { limit, offset } = data as Record<string, any>;\n\n    if (typeof limit !== 'undefined') {\n        limit = parseInt(limit, 10);\n\n        if (!Number.isNaN(limit) && limit > 0) {\n            pagination.limit = limit;\n        } else if (options.throwOnFailure) {\n            throw PaginationParseError.keyValueInvalid('limit');\n        }\n    }\n\n    if (typeof offset !== 'undefined') {\n        offset = parseInt(offset, 10);\n\n        if (!Number.isNaN(offset) && offset >= 0) {\n            pagination.offset = offset;\n        } else if (options.throwOnFailure) {\n            throw PaginationParseError.keyValueInvalid('offset');\n        }\n    }\n\n    return finalizePagination(pagination, options);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../../type';\nimport type { RelationsBuildInput } from './type';\nimport { flattenToKeyPathArray, merge } from '../../utils';\n\nexport function buildQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input?: RelationsBuildInput<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function mergeQueryRelations(\n    target?: string[],\n    source?: string[],\n) : string[] {\n    return merge(target || [], source || []);\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BuildError } from '../../../errors';\n\nexport class RelationsBuildError extends BuildError {\n\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ParseError } from '../../../errors';\n\nexport class RelationsParseError extends ParseError {\n\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function includeParents(\n    data: string[],\n) : string[] {\n    for (let i = 0; i < data.length; i++) {\n        const parts: string[] = data[i].split('.');\n\n        while (parts.length > 0) {\n            parts.pop();\n\n            if (parts.length > 0) {\n                const value = parts.join('.');\n                if (data.indexOf(value) === -1) {\n                    data.unshift(value);\n                }\n            }\n        }\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidRelationPath(input: string) : boolean {\n    return /^[a-zA-Z0-9_-]+([.]*[a-zA-Z0-9_-])*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../../type';\nimport { applyMapping, hasOwnProperty } from '../../utils';\nimport { isPathCoveredByParseAllowedOption } from '../utils';\nimport { RelationsParseError } from './errors';\n\nimport type { RelationsParseOptions, RelationsParseOutput } from './type';\nimport { includeParents, isValidRelationPath } from './utils';\n\n// --------------------------------------------------\n\nexport function parseQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options: RelationsParseOptions<T> = {},\n): RelationsParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (\n        Array.isArray(options.allowed) &&\n        options.allowed.length === 0\n    ) {\n        return [];\n    }\n\n    options.mapping = options.mapping || {};\n    options.pathMapping = options.pathMapping || {};\n    if (typeof options.includeParents === 'undefined') {\n        options.includeParents = true;\n    }\n\n    let items: string[] = [];\n\n    if (typeof input === 'string') {\n        items = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                items.push(input[i]);\n            } else {\n                throw RelationsParseError.inputInvalid();\n            }\n        }\n    } else if (options.throwOnFailure) {\n        throw RelationsParseError.inputInvalid();\n    }\n\n    if (items.length === 0) {\n        return [];\n    }\n\n    const mappingKeys = Object.keys(options.mapping);\n    if (mappingKeys.length > 0) {\n        for (let i = 0; i < items.length; i++) {\n            items[i] = applyMapping(items[i], options.mapping);\n        }\n    }\n\n    for (let j = items.length - 1; j >= 0; j--) {\n        let isValid : boolean;\n        if (options.allowed) {\n            isValid = isPathCoveredByParseAllowedOption(options.allowed as string[], items[j]);\n        } else {\n            isValid = isValidRelationPath(items[j]);\n        }\n\n        if (!isValid) {\n            if (options.throwOnFailure) {\n                throw RelationsParseError.keyInvalid(items[j]);\n            }\n\n            items.splice(j, 1);\n        }\n    }\n\n    if (options.includeParents) {\n        if (Array.isArray(options.includeParents)) {\n            const parentIncludes = items.filter(\n                (item) => item.includes('.') &&\n                    (options.includeParents as string[]).filter((parent) => item.startsWith(parent)).length > 0,\n            );\n            items.unshift(...includeParents(parentIncludes));\n        } else {\n            items = includeParents(items);\n        }\n    }\n\n    items = Array.from(new Set(items));\n\n    return items\n        .map((key) => {\n            const parts = key.split('.');\n\n            let value : string;\n            if (\n                options.pathMapping &&\n                hasOwnProperty(options.pathMapping, key)\n            ) {\n                value = options.pathMapping[key];\n            } else {\n                value = parts.pop() as string;\n            }\n\n            return {\n                key,\n                value,\n            };\n        });\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type {\n    Flatten, KeyWithOptionalPrefix, NestedKeys, OnlyObject, SimpleKeys,\n} from '../../type';\nimport type { RelationsParseOutput } from '../relations';\nimport type {\n    ParseAllowedOption,\n} from '../type';\n\nexport enum SortDirection {\n    ASC = 'ASC',\n    DESC = 'DESC',\n}\n\n// -----------------------------------------------------------\n// Build\n// -----------------------------------------------------------\n\ntype SortWithOperator<T extends string> = KeyWithOptionalPrefix<T, '-'>;\n\nexport type SortBuildInput<T extends Record<string, any>> =\n    {\n        [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n            SortBuildInput<Flatten<T[K]>> :\n            `${SortDirection}`\n    }\n    |\n    (\n        SortWithOperator<SimpleKeys<T>>[] |\n        {\n            [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n                SortBuildInput<Flatten<T[K]>> :\n                `${SortDirection}`\n        }\n    )[]\n    |\n    SortWithOperator<NestedKeys<T>>[] |\n    SortWithOperator<NestedKeys<T>>;\n\n// -----------------------------------------------------------\n// Parse\n// -----------------------------------------------------------\n\nexport type SortParseDefaultOption<T extends Record<string, any>> = {\n    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n        SortParseDefaultOption<Flatten<T[K]>> :\n        `${SortDirection}`\n} | {\n    [K in NestedKeys<T>]?: `${SortDirection}`\n};\n\nexport type SortParseOptions<\n    T extends Record<string, any> = Record<string, any>,\n    > = {\n        allowed?: ParseAllowedOption<T>,\n        mapping?: Record<string, string>,\n        default?: SortParseDefaultOption<T>,\n        defaultPath?: string,\n        throwOnFailure?: boolean,\n        relations?: RelationsParseOutput,\n    };\nexport type SortParseOutputElement = {\n    key: string,\n    value: `${SortDirection}`,\n    path?: string\n};\nexport type SortParseOutput = SortParseOutputElement[];\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\nimport type { ObjectLiteral } from '../../type';\nimport type { SortBuildInput } from './type';\nimport { SortDirection } from './type';\nimport { flattenToKeyPathArray, merge } from '../../utils';\n\nexport function buildQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data?: SortBuildInput<T>,\n) {\n    if (typeof data === 'undefined') {\n        return [];\n    }\n\n    if (typeof data === 'string') {\n        return [data];\n    }\n\n    return flattenToKeyPathArray(data, {\n        transformer: ((input, output, path) => {\n            if (\n                typeof input === 'string' &&\n                path &&\n                (\n                    input === SortDirection.ASC ||\n                    input === SortDirection.DESC\n                )\n            ) {\n                if (input === SortDirection.DESC) {\n                    output.push(`-${path}`);\n                } else {\n                    output.push(path);\n                }\n\n                return true;\n            }\n\n            return undefined;\n        }),\n    });\n}\n\nexport function mergeQuerySort(\n    target?: string[],\n    source?: string[],\n) {\n    return merge(target || [], source || []);\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BuildError } from '../../../errors';\n\nexport class SortBuildError extends BuildError {\n\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { ParseError } from '../../../errors';\n\nexport class SortParseError extends ParseError {\n\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { SortDirection } from './type';\n\nexport function parseSortValue(value: string) : {value: string, direction: `${SortDirection}`} {\n    let direction: SortDirection = SortDirection.ASC;\n    if (value.substring(0, 1) === '-') {\n        direction = SortDirection.DESC;\n        value = value.substring(1);\n    }\n\n    return {\n        direction,\n        value,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport type { ObjectLiteral } from '../../type';\nimport {\n    applyMapping,\n    buildKeyPath,\n    buildKeyWithPath,\n    flattenNestedObject,\n    hasOwnProperty,\n    isPathAllowedByRelations,\n    parseKey,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport type { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\nimport { SortParseError } from './errors';\n\nimport type {\n    SortParseOptions,\n    SortParseOutput,\n    SortParseOutputElement,\n} from './type';\nimport { parseSortValue } from './utils';\n\n// --------------------------------------------------\n\nfunction isMultiDimensionalArray(arr: unknown) : arr is unknown[][] {\n    if (!Array.isArray(arr)) {\n        return false;\n    }\n\n    return arr.length > 0 && Array.isArray(arr[0]);\n}\n\nfunction buildDefaultSortParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: SortParseOptions<T>,\n) : SortParseOutput {\n    if (options.default) {\n        const output : SortParseOutput = [];\n\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = parseKey(keys[i]);\n\n            let path : string | undefined;\n            if (fieldDetails.path) {\n                path = fieldDetails.path;\n            } else if (options.defaultPath) {\n                path = options.defaultPath;\n            }\n\n            output.push({\n                key: fieldDetails.name,\n                ...(path ? { path } : {}),\n                value: flatten[keys[i]],\n            });\n        }\n\n        return output;\n    }\n\n    return [];\n}\n\n/**\n * Transform sort data to appreciate data format.\n * @param data\n * @param options\n */\nexport function parseQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: SortParseOptions<T>,\n) : SortParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        const allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (allowed.length === 0) {\n            return buildDefaultSortParseOutput(options);\n        }\n    }\n\n    options.mapping = options.mapping || {};\n\n    /* istanbul ignore next */\n    if (\n        typeof data !== 'string' &&\n        !Array.isArray(data) &&\n        !isObject(data)\n    ) {\n        if (options.throwOnFailure) {\n            throw SortParseError.inputInvalid();\n        }\n\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (\n        typeof options.allowed === 'undefined' &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    let parts : string[] = [];\n\n    if (typeof data === 'string') {\n        parts = data.split(',');\n    }\n\n    if (Array.isArray(data)) {\n        parts = data.filter((item) => typeof item === 'string');\n    }\n\n    if (isObject(data)) {\n        const keys = Object.keys(data);\n        for (let i = 0; i < keys.length; i++) {\n            /* istanbul ignore next */\n            if (\n                !hasOwnProperty(data, keys[i]) ||\n                typeof keys[i] !== 'string' ||\n                typeof data[keys[i]] !== 'string'\n            ) {\n                if (options.throwOnFailure) {\n                    throw SortParseError.keyValueInvalid(keys[i]);\n                }\n\n                continue;\n            }\n\n            const fieldPrefix = (data[keys[i]] as string)\n                .toLowerCase() === 'desc' ? '-' : '';\n\n            parts.push(fieldPrefix + keys[i]);\n        }\n    }\n\n    const items : Record<string, SortParseOutputElement> = {};\n\n    let matched = false;\n\n    for (let i = 0; i < parts.length; i++) {\n        const { value, direction } = parseSortValue(parts[i]);\n        parts[i] = value;\n\n        const key: string = applyMapping(parts[i], options.mapping);\n\n        const fieldDetails = parseKey(key);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            if (options.throwOnFailure) {\n                throw SortParseError.keyInvalid(fieldDetails.name);\n            }\n\n            continue;\n        }\n\n        if (\n            !isPathAllowedByRelations(fieldDetails.path, options.relations) &&\n            typeof fieldDetails.path !== 'undefined'\n        ) {\n            if (options.throwOnFailure) {\n                throw SortParseError.keyPathInvalid(fieldDetails.path);\n            }\n\n            continue;\n        }\n\n        const keyWithAlias = buildKeyWithPath(fieldDetails);\n        if (\n            typeof options.allowed !== 'undefined' &&\n            !isMultiDimensionalArray(options.allowed) &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [key, keyWithAlias])\n        ) {\n            if (options.throwOnFailure) {\n                throw SortParseError.keyNotAllowed(fieldDetails.name);\n            }\n\n            continue;\n        }\n\n        matched = true;\n\n        let path : string | undefined;\n        if (fieldDetails.path) {\n            path = fieldDetails.path;\n        } else if (options.defaultPath) {\n            path = options.defaultPath;\n        }\n\n        items[keyWithAlias] = {\n            key: fieldDetails.name,\n            ...(path ? { path } : {}),\n            value: direction,\n        };\n    }\n\n    if (!matched) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (isMultiDimensionalArray(options.allowed)) {\n        // eslint-disable-next-line no-labels,no-restricted-syntax\n        outerLoop:\n        for (let i = 0; i < options.allowed.length; i++) {\n            const temp : SortParseOutput = [];\n\n            const keyPaths = flattenParseAllowedOption(options.allowed[i] as string[]);\n\n            for (let j = 0; j < keyPaths.length; j++) {\n                let keyWithAlias : string = keyPaths[j];\n                let key : string;\n\n                const parts = keyWithAlias.split('.');\n                if (parts.length > 1) {\n                    key = parts.pop() as string;\n                } else {\n                    key = keyWithAlias;\n\n                    keyWithAlias = buildKeyPath(key, options.defaultPath);\n                }\n\n                if (\n                    hasOwnProperty(items, key) ||\n                    hasOwnProperty(items, keyWithAlias)\n                ) {\n                    const item = hasOwnProperty(items, key) ?\n                        items[key] :\n                        items[keyWithAlias];\n\n                    temp.push(item);\n                } else {\n                    // eslint-disable-next-line no-labels\n                    continue outerLoop;\n                }\n            }\n\n            return temp;\n        }\n\n        // if we get no match, the sort data is invalid.\n        return [];\n    }\n\n    return Object.values(items);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../type';\nimport type { BuildInput } from './type';\nimport {\n    buildQueryFields,\n    buildQueryFilters,\n    buildQueryRelations,\n    buildQuerySort,\n    mergeQueryFields,\n    mergeQueryFilters,\n    mergeQueryPagination,\n    mergeQueryRelations,\n    mergeQuerySort,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport {\n    buildURLQueryString,\n} from '../utils';\n\nexport function buildQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input?: BuildInput<T>,\n) : string {\n    if (!input) {\n        return '';\n    }\n\n    const query: { [key in URLParameter]?: unknown } = {};\n\n    if (\n        typeof input[Parameter.FIELDS] !== 'undefined' ||\n        typeof input[URLParameter.FIELDS] !== 'undefined'\n    ) {\n        query[URLParameter.FIELDS] = mergeQueryFields(\n            buildQueryFields(input[Parameter.FIELDS]),\n            buildQueryFields(input[URLParameter.FIELDS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.FILTERS] !== 'undefined' ||\n        typeof input[URLParameter.FILTERS] !== 'undefined'\n    ) {\n        query[URLParameter.FILTERS] = mergeQueryFilters(\n            buildQueryFilters(input[Parameter.FILTERS]),\n            buildQueryFilters(input[URLParameter.FILTERS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.PAGINATION] !== 'undefined' ||\n        typeof input[URLParameter.PAGINATION] !== 'undefined'\n    ) {\n        query[URLParameter.PAGINATION] = mergeQueryPagination(\n            input[Parameter.PAGINATION],\n            input[URLParameter.PAGINATION],\n        );\n    }\n\n    if (\n        typeof input[Parameter.RELATIONS] !== 'undefined' ||\n        typeof input[URLParameter.RELATIONS] !== 'undefined'\n    ) {\n        query[URLParameter.RELATIONS] = mergeQueryRelations(\n            buildQueryRelations(input[Parameter.RELATIONS]),\n            buildQueryRelations(input[URLParameter.RELATIONS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.SORT] !== 'undefined' ||\n        typeof input[URLParameter.SORT] !== 'undefined'\n    ) {\n        query[URLParameter.SORT] = mergeQuerySort(\n            buildQuerySort(input[Parameter.SORT]),\n            buildQuerySort(input[URLParameter.SORT]),\n        );\n    }\n\n    return buildURLQueryString(query);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { RelationsParseOutput } from '../../parameter';\nimport {\n    parseQueryFields, parseQueryFilters, parseQueryPagination, parseQueryRelations, parseQuerySort,\n} from '../../parameter';\nimport {\n    Parameter, URLParameter,\n} from '../../constants';\nimport type { ObjectLiteral } from '../../type';\nimport type { ParseParameterOptions, ParseParameterOutput } from './type';\n\nexport function parseQueryParameter<\n    P extends `${Parameter}` | `${URLParameter}`,\n    T extends ObjectLiteral = ObjectLiteral,\n    >(\n    key: P,\n    data: unknown,\n    options?: ParseParameterOptions<P, T>,\n    relations?: RelationsParseOutput,\n): ParseParameterOutput<P> {\n    switch (key) {\n        case Parameter.FIELDS:\n        case URLParameter.FIELDS:\n            return (parseQueryFields(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FIELDS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.FILTERS:\n        case URLParameter.FILTERS:\n            return (parseQueryFilters(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FILTERS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.PAGINATION:\n        case URLParameter.PAGINATION:\n            return (parseQueryPagination(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.PAGINATION>,\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.RELATIONS:\n        case URLParameter.RELATIONS:\n            return (parseQueryRelations(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.RELATIONS>,\n                },\n            ) as ParseParameterOutput<P>);\n        default:\n            return (parseQuerySort(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.SORT>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n    }\n}\n\nfunction invalidToEmptyObject<V>(\n    value: V | boolean,\n): NonNullable<V> {\n    return typeof value === 'boolean' ||\n        typeof value === 'undefined' ?\n        {} as NonNullable<V> :\n        value as NonNullable<V>;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\n\nexport function buildQueryParameterOptions<T extends Record<string, any>>(\n    input?: T | boolean,\n) : T {\n    if (isObject(input)) {\n        return input;\n    }\n\n    return {} as T;\n}\n\ntype QueryParameterEnabledContext = {\n    data: unknown,\n    options?: Record<string, any> | boolean\n};\nexport function isQueryParameterEnabled(context: QueryParameterEnabledContext) : boolean {\n    if (typeof context.options === 'boolean') {\n        return context.options;\n    }\n\n    if (\n        typeof context.data !== 'undefined' &&\n        typeof context.options === 'undefined'\n    ) {\n        return true;\n    }\n\n    if (isObject(context.options)) {\n        if (typeof context.options.default !== 'undefined') {\n            return true;\n        }\n\n        return typeof context.data !== 'undefined';\n    }\n\n    return false;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type {\n    FieldsParseOutput,\n    FiltersParseOutput,\n    PaginationParseOutput,\n    RelationsParseOutput,\n    SortParseOutput,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport type { ObjectLiteral } from '../type';\nimport { buildQueryParameterOptions, isQueryParameterEnabled, parseQueryParameter } from './parameter';\nimport type { ParseInput, ParseOptions, ParseOutput } from './type';\n\nexport function parseQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input: ParseInput,\n    options: ParseOptions<T> = {},\n) : ParseOutput {\n    options = options || {};\n\n    const mergeWithGlobalOptions = <T extends {[key: string]: any} & {\n        defaultPath?: string,\n        throwOnError?: boolean\n    }>(data?: T) : T => {\n        if (typeof data !== 'undefined') {\n            if (typeof data.defaultPath === 'undefined') {\n                data.defaultPath = options.defaultPath;\n            }\n\n            if (typeof data.throwOnError === 'undefined') {\n                data.throwOnError = options.throwOnFailure;\n            }\n        }\n\n        return data || {} as T;\n    };\n\n    const output : ParseOutput = {};\n    if (options.defaultPath) {\n        output.defaultPath = options.defaultPath;\n    }\n\n    let relations : RelationsParseOutput | undefined;\n\n    const keys : Parameter[] = [\n        // relations must be first parameter\n        Parameter.RELATIONS,\n\n        Parameter.FIELDS,\n        Parameter.FILTERS,\n        Parameter.PAGINATION,\n        Parameter.SORT,\n    ];\n\n    for (let i = 0; i < keys.length; i++) {\n        const key : Parameter = keys[i];\n\n        switch (key) {\n            case Parameter.RELATIONS: {\n                const value = input[Parameter.RELATIONS] || input[URLParameter.RELATIONS];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.RELATIONS] })) {\n                    relations = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.RELATIONS]),\n                    );\n\n                    output[Parameter.RELATIONS] = relations;\n                }\n                break;\n            }\n            case Parameter.FIELDS: {\n                const value = input[Parameter.FIELDS] || input[URLParameter.FIELDS];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.FIELDS] })) {\n                    output[Parameter.FIELDS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FIELDS])),\n                        relations,\n                    ) as FieldsParseOutput;\n                }\n                break;\n            }\n            case Parameter.FILTERS: {\n                const value = input[Parameter.FILTERS] || input[URLParameter.FILTERS];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.FILTERS] })) {\n                    output[Parameter.FILTERS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FILTERS])),\n                        relations,\n                    ) as FiltersParseOutput;\n                }\n                break;\n            }\n            case Parameter.PAGINATION: {\n                const value = input[Parameter.PAGINATION] || input[URLParameter.PAGINATION];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.PAGINATION] })) {\n                    output[Parameter.PAGINATION] = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.PAGINATION]),\n                        relations,\n                    ) as PaginationParseOutput;\n                }\n                break;\n            }\n            case Parameter.SORT: {\n                const value = input[Parameter.SORT] || input[URLParameter.SORT];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.SORT] })) {\n                    output[Parameter.SORT] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.SORT])),\n                        relations,\n                    ) as SortParseOutput;\n                }\n                break;\n            }\n        }\n    }\n\n    return output;\n}\n"],"names":["Parameter","FILTERS","FIELDS","PAGINATION","RELATIONS","SORT","URLParameter","DEFAULT_ID","buildKeyPath","key","prefix","flattenToKeyPathArray","input","options","output","transformer","result","Array","isArray","i","length","j","push","keys","Object","value","data","groupArrayByKeyPath","pathItems","parts","split","name","pop","join","prototype","hasOwnProperty","call","isObject","item","obj","prop","flattenNestedObject","prefixParts","destinationKey","applyMapping","map","onlyKey","run","shift","found","rest","copy","last","unshift","parseKey","field","path","undefined","merge","createMerger","clone","inPlace","array","arrayDistinct","isPathAllowedByRelations","includes","some","include","buildKeyWithPath","details","buildURLQueryString","withQuestionMark","query","valueKeys","v","encodeURIComponent","buildQueryFields","mergeQueryFields","target","source","FieldOperator","INCLUDE","EXCLUDE","ErrorCode","NONE","INPUT_INVALID","KEY_INVALID","KEY_PATH_INVALID","KEY_NOT_ALLOWED","KEY_VALUE_INVALID","BaseError","Base","code","getOption","BuildError","constructor","message","ParseError","inputInvalid","keyNotAllowed","keyInvalid","keyPathInvalid","keyValueInvalid","FieldsBuildError","FieldsParseError","flattenParseAllowedOption","isPathCoveredByParseAllowedOption","paths","items","indexOf","buildFieldDomainRecords","domainFields","parseFieldsInput","isValidFieldName","test","buildReverseRecord","record","parseQueryFields","defaultDomainFields","default","allowedDomainFields","allowed","throwOnFailure","mapping","reverseMapping","distinctArray","relations","fields","transformed","included","excluded","operator","character","substring","isValid","from","Set","index","splice","destPath","defaultPath","FilterComparisonOperator","EQUAL","NOT_EQUAL","LIKE","NOT_LIKE","LESS_THAN_EQUAL","LESS_THAN","GREATER_THAN_EQUAL","GREATER_THAN","IN","NOT_IN","FilterInputOperatorValue","NEGATION","MORE_THAN_EQUAL","MORE_THAN","buildQueryFilters","mergeQueryFilters","FiltersBuildError","FiltersParseError","transformFilterValue","trim","lower","toLowerCase","num","Number","isNaN","filter","n","matchOperator","position","match","parseFilterValue","negation","transformFiltersParseOutputElement","element","buildDefaultFiltersParseOutput","inputKeys","defaultByElement","values","flatten","keyDetails","keyWithPath","parseQueryFilters","fieldDetails","fullKey","validate","mergeQueryPagination","PaginationBuildError","PaginationParseError","limitExceeded","limit","finalizePagination","maxLimit","offset","parseQueryPagination","pagination","parseInt","buildQueryRelations","mergeQueryRelations","RelationsBuildError","RelationsParseError","includeParents","isValidRelationPath","parseQueryRelations","pathMapping","mappingKeys","parentIncludes","parent","startsWith","SortDirection","ASC","DESC","buildQuerySort","mergeQuerySort","SortBuildError","SortParseError","parseSortValue","direction","isMultiDimensionalArray","arr","buildDefaultSortParseOutput","parseQuerySort","fieldPrefix","matched","keyWithAlias","outerLoop","temp","keyPaths","buildQuery","parseQueryParameter","invalidToEmptyObject","buildQueryParameterOptions","isQueryParameterEnabled","context","parseQuery","mergeWithGlobalOptions","throwOnError"],"mappings":"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"}