'use strict';

var stdEnv = require('std-env');

function has(key) {
    if (Reflect.has(stdEnv.env, key)) {
        return true;
    }
    /* istanbul ignore next */ return Reflect.has(globalThis.process?.env, key);
}

function oneOf(input) {
    for(let i = 0; i < input.length; i++){
        if (typeof input[i] !== 'undefined') {
            return input[i];
        }
    }
    return undefined;
}

function orFail(output) {
    if (typeof output === 'undefined') {
        throw new Error('The environment variable could not be read.');
    }
    return output;
}

function read(key, alt) {
    if (typeof key === 'undefined') {
        const keys = Reflect.ownKeys(stdEnv.env);
        const output = {};
        for(let i = 0; i < keys.length; i++){
            output[keys[i]] = stdEnv.env[keys[i]];
        }
        return output;
    }
    if (Reflect.has(stdEnv.env, key)) {
        return stdEnv.env[key];
    }
    /* istanbul ignore next */ if (Reflect.has(globalThis.process?.env, key)) {
        return globalThis.process?.env[key];
    }
    return alt;
}

function toArray(input, separator = ',') {
    if (typeof input !== 'string') {
        return undefined;
    }
    return input.split(separator).map((el)=>el.trim()).filter(Boolean);
}

function toBool(value) {
    switch(value){
        case true:
        case 'true':
        case 't':
        case '1':
            return true;
        case false:
        case 'false':
        case 'f':
        case '0':
            return false;
    }
    return undefined;
}

function toFloat(value) {
    const num = Number.parseFloat(value);
    if (Number.isNaN(num) || Number.isNaN(value)) {
        return undefined;
    }
    return num;
}

function toInt(value) {
    const num = Number.parseInt(value, 10);
    if (Number.isNaN(num)) {
        return undefined;
    }
    return num;
}

function toNumber(value) {
    const num = Number(value);
    if (Number.isNaN(num)) {
        return undefined;
    }
    return num;
}

function readArray(key, alt) {
    const value = read(key);
    if (typeof value === 'undefined') {
        return alt;
    }
    return toArray(value) ?? alt;
}

function readBool(key, alt) {
    const value = read(key);
    if (typeof value !== 'undefined') {
        return toBool(value) ?? alt;
    }
    return alt;
}

function readInt(key, alt) {
    const value = read(key);
    if (typeof value !== 'undefined') {
        return toInt(value) ?? alt;
    }
    return alt;
}

function readFloat(key, alt) {
    const value = read(key);
    if (typeof value !== 'undefined') {
        return toFloat(value) ?? alt;
    }
    return alt;
}

function readNumber(key, alt) {
    const value = read(key);
    if (typeof value !== 'undefined') {
        return toNumber(value) ?? alt;
    }
    return alt;
}

function readNumberArray(key) {
    const value = readArray(key);
    if (!value) {
        return undefined;
    }
    const nums = value.map((el)=>toNumber(el));
    if (nums.some((el)=>typeof el === 'undefined')) {
        return undefined;
    }
    return nums;
}

function write(key, value) {
    if (typeof value === 'undefined') {
        delete stdEnv.env[key];
        return;
    }
    stdEnv.env[key] = value;
}

exports.has = has;
exports.oneOf = oneOf;
exports.orFail = orFail;
exports.read = read;
exports.readArray = readArray;
exports.readBool = readBool;
exports.readFloat = readFloat;
exports.readInt = readInt;
exports.readNumber = readNumber;
exports.readNumberArray = readNumberArray;
exports.toArray = toArray;
exports.toBool = toBool;
exports.toFloat = toFloat;
exports.toInt = toInt;
exports.toNumber = toNumber;
exports.write = write;
//# sourceMappingURL=index.cjs.map
